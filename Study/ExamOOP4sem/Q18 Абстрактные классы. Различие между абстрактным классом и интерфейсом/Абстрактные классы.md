# **Абстрактный класс** 
— это класс, [[Классы и объекты#^de8d55|экземпляр]] которого не может быть создан напрямую. Абстрактные классы используются, когда мы хотим определить общий шаблон для группы связанных классов, но оставить некоторые методы или свойства для реализации производными классами.

- Абстрактный класс не может быть напрямую инстанцирован. Мы можем только создавать объекты производных классов.
- Абстрактные методы объявлены в абстрактных классах, но не имеют реализации, для их реализации требуются [[Наследование|производные классы]].
- Абстрактный класс также содержит [[свойства]] и поля, к которым могут обращаться производные классы.

***Важные моменты:***

- Обычно мы используем абстрактный класс во время [[Наследование|наследования]] .
- Пользователь должен использовать  ключевое слово `override`  до того, как метод будет объявлен как абстрактный в дочернем классе; абстрактный класс используется для наследования в дочернем классе.
- Абстрактный класс не может быть унаследован [[Значимые типы#^aeaf5d|структурами]].
- Он может содержать [[Конструкторы]] или [[Деструкторы]].
- Он может реализовывать функции с помощью неабстрактных методов.
- Он не может поддерживать множественное наследование.
- Он не может быть [[Статические компоненты класса|статичным]].

```cs
abstract class Transport
{
    public void Move()
    {
        Console.WriteLine("Транспортное средство движется");
    }
}
```

### *Абстрактные члены классов*

Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова `abstract` и не имеют никакого функционала. В частности, абстрактными могут быть:

- Методы
- `Свойства`
- Индексаторы
- `События`

Абстрактные члены классов не должны иметь модификатор `private`. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором `override` (как и при обычном переопределении виртуальных методов и свойств). ]

> [!warning]
> Если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как абстрактный.

Абстрактные члены также, как и [[Переопределение методов|виртуальные]], являются частью [[Полиморфизм|полиморфизма]]. Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.